/* vim: set ft=c: */
#include <assert.h>
#include <syslog.h>
#include <stdlib.h>
#include <arpa/inet.h>

#include "bd.h"
#include "paquete.h"

/**
 * print_sqlca()
 * -------------------------------------------------------------------------
 * Imprime error en caso de ocurrir alguno
 */
void print_sqlca();

EXEC SQL WHENEVER SQLERROR CALL print_sqlca();
EXEC SQL WHENEVER SQLWARNING SQLPRINT;


/**
 * bd_conectar()
 * -------------------------------------------------------------------------
 * Conecta con la base de datos
 */
int bd_conectar() {
    EXEC SQL CONNECT TO POSTGRES_CONNECTION_STRING USER POSTGRES_USER/
                                                        POSTGRES_PASSWD;
    if(sqlca.sqlcode == 0) syslog(LOG_INFO, "Base de datos conectada");
    return sqlca.sqlcode;
}

/**
 * bd_desconectar()
 * -------------------------------------------------------------------------
 * Desconecta con la base de datos
 */
void bd_desconectar() {
    EXEC SQL DISCONNECT ALL;
    syslog(LOG_INFO, "Base de datos desconectada");
}

/**
 * bd_commit()
 * -------------------------------------------------------------------------
 * Hace un commit de la transaccion en la base de datos
 */
void bd_commit() {
    EXEC SQL COMMIT;
}

/**
 * get_paquetes(**paquetes, *cfg)
 * -------------------------------------------------------------------------
 * Obtiene los paquetes capturados segun configuracion pasada por parametro.
 * Devuelve la cantidad de paquetes en el array de paquetes
 */
int bd_paquetes(struct s_analizador* analizador,
                int (*callback)(const struct s_analizador*,
                                const struct paquete*))
{
    struct paquete paquete;
    int i;
    /* declaracion de variables usadas en postgres */
    EXEC SQL BEGIN DECLARE SECTION;
        const char *stmt = "SELECT ip_origen, ip_destino, puerto_origen,"
                     "       puerto_destino, protocolo, bytes, direccion "
                     "FROM paquetes";
        const char *count = "SELECT count(1) FROM paquetes";
        typedef struct {
            int ip_origen;
            int ip_destino;
            int puerto_origen;
            int puerto_destino;
            int protocolo;
            int bytes;
            int direccion;
        } t_paquete;
        t_paquete *paquetes;
        int cantidad;
    EXEC SQL END DECLARE SECTION;

    /* preparo consultas */
    EXEC SQL PREPARE stmt1 FROM :stmt;
    EXEC SQL PREPARE count1 FROM :count;

    /* obtengo la cantidad de filas necesarias */
    EXEC SQL EXECUTE count1 INTO :cantidad;

    /* obtengo la memoria necesaria para cargar todas las filas e inicializo la
     * seccion de memoria con ceros
     */
    paquetes = malloc(sizeof(t_paquete) * cantidad);
    if (paquetes == NULL) {
        fprintf(stderr, "No hay memoria disponible para analizar %d paquetes\n", 
               cantidad);
        syslog(LOG_ERR, "No hay memoria disponible para analizar %d paquetes", 
               cantidad);
        exit(EXIT_FAILURE);
    }
    memset(paquetes, 0, sizeof(t_paquete) * cantidad);

    /* obtengo los paquetes */
    EXEC SQL EXECUTE stmt1 INTO :paquetes;

    for(i = 0; i < cantidad; i++) {
        paquete.direccion = -1;
        paquete.origen.s_addr = htonl((paquetes + i)->ip_origen);
        paquete.destino.s_addr = htonl((paquetes + i)->ip_destino);
        paquete.puerto_origen = (paquetes + i)->puerto_origen;
        paquete.puerto_destino = (paquetes + i)->puerto_destino;
        paquete.protocolo = (paquetes + i)->protocolo;
        paquete.bytes = (paquetes + i)->bytes;
        paquete.direccion = (paquetes + i)->direccion;
        /* analizo paquete */
        callback(analizador, &paquete);
    }
    /* libero recursos */
    EXEC SQL COMMIT;
    free(paquetes);
    return cantidad;
}

/**
 * print_sqlca()
 * -------------------------------------------------------------------------
 * Imprime error en caso de ocurrir alguno
 */
void print_sqlca() {
    syslog(LOG_ERR, "==== sqlca ====\n");
    syslog(LOG_ERR, "sqlcode: %ld\n", sqlca.sqlcode);
    syslog(LOG_ERR, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    syslog(LOG_ERR, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    syslog(LOG_ERR, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],
                                                          sqlca.sqlerrd[1],
                                                          sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],
                                                          sqlca.sqlerrd[4],
                                                          sqlca.sqlerrd[5]);
    syslog(LOG_ERR, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0],
                                                          sqlca.sqlwarn[1],
                                                          sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3],
                                                          sqlca.sqlwarn[4],
                                                          sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6],
                                                          sqlca.sqlwarn[7]);
    syslog(LOG_ERR, "sqlstate: %5s\n", sqlca.sqlstate);
    syslog(LOG_ERR, "===============\n");
    fprintf(stderr, "Error: %s\n", sqlca.sqlerrm.sqlerrmc);
    exit(EXIT_FAILURE);
}
