/* vim: set ft=c: */
#include <assert.h>
#include <syslog.h>
#include <stdlib.h>
#include <arpa/inet.h>

#include "bd.h"
#include "paquete.h"

/**
 * print_sqlca()
 * -------------------------------------------------------------------------
 * Imprime error en caso de ocurrir alguno
 */
void print_sqlca();

EXEC SQL WHENEVER SQLERROR CALL print_sqlca();
EXEC SQL WHENEVER SQLWARNING SQLPRINT;


/**
 * bd_conectar()
 * -------------------------------------------------------------------------
 * Conecta con la base de datos
 */
int bd_conectar() {
    EXEC SQL CONNECT TO POSTGRES_CONNECTION_STRING USER POSTGRES_USER/
                                                        POSTGRES_PASSWD;
    if(sqlca.sqlcode == 0) syslog(LOG_INFO, "Base de datos conectada");
    return sqlca.sqlcode;
}

/**
 * bd_desconectar()
 * -------------------------------------------------------------------------
 * Desconecta con la base de datos
 */
void bd_desconectar() {
    EXEC SQL DISCONNECT ALL;
    syslog(LOG_INFO, "Base de datos desconectada");
}

/**
 * bd_commit()
 * -------------------------------------------------------------------------
 * Hace un commit de la transaccion en la base de datos
 */
void bd_commit() {
    EXEC SQL COMMIT;
}

/**
 * obtener_paquetes
 * -------------------------------------------------------------------------
 *  Obtiene los paquetes capturados segun configuracion pasada por parametro.
 *  Devuelve la cantidad de paquetes en el array de paquetes
 */
int obtener_paquetes(struct s_analizador* analizador,
                     int (*callback)(const struct s_analizador*,
                                     const struct paquete*))
{
    struct paquete paquete;
    int i;
    /* declaracion de variables usadas en postgres */
    EXEC SQL BEGIN DECLARE SECTION;
        const char *stmt = "SELECT ip_origen, ip_destino, puerto_origen, "
                                  "puerto_destino, protocolo, bytes, "
                                  "direccion "
                           "FROM paquetes "
                           "WHERE hora_captura "
                           "BETWEEN to_timestamp(?) "
                           "AND to_timestamp(?)";
        const char *count = "SELECT count(1)"
                            "FROM paquetes "
                            "WHERE hora_captura "
                            "BETWEEN to_timestamp(?) "
                            "AND to_timestamp(?)";
        typedef struct {
            int ip_origen;
            int ip_destino;
            int puerto_origen;
            int puerto_destino;
            int protocolo;
            int bytes;
            int direccion;
        } t_paquete;
        t_paquete *paquetes;
        int cantidad;
        int t_min, t_max; /* intervalo de analisis */
    EXEC SQL END DECLARE SECTION;

    t_min = analizador->tiempo_inicio;
    t_max = analizador->tiempo_fin;

    /* preparo consultas */
    EXEC SQL PREPARE stmt1 FROM :stmt;
    EXEC SQL PREPARE count1 FROM :count;

    /* obtengo la cantidad de filas necesarias */
    EXEC SQL EXECUTE count1 INTO :cantidad USING :t_min, :t_max;

    /* obtengo la memoria necesaria para cargar todas las filas e inicializo la
     * seccion de memoria con ceros.
     */
    paquetes = malloc(sizeof(t_paquete) * cantidad);
    if (paquetes == NULL) {
        fprintf(stderr,
                "No hay memoria disponible para analizar %d paquetes\n",
                cantidad);
        syslog(LOG_ERR,
               "No hay memoria disponible para analizar %d paquetes",
               cantidad);
        exit(EXIT_FAILURE);
    }
    memset(paquetes, 0, sizeof(t_paquete) * cantidad);

    /* obtengo los paquetes */
    EXEC SQL EXECUTE stmt1 INTO :paquetes USING :t_min, :t_max;

    #pragma omp parallel for private(i, paquete)
    for(i = 0; i < cantidad; i++) {
        paquete.origen.s_addr = htonl((paquetes + i)->ip_origen);
        paquete.destino.s_addr = htonl((paquetes + i)->ip_destino);
        paquete.puerto_origen = (paquetes + i)->puerto_origen;
        paquete.puerto_destino = (paquetes + i)->puerto_destino;
        paquete.protocolo = (paquetes + i)->protocolo;
        paquete.bytes = (paquetes + i)->bytes;
        paquete.direccion = (paquetes + i)->direccion;
        /* analizo paquete */
        callback(analizador, &paquete);
    }
    /* libero recursos */
    EXEC SQL COMMIT;
    free(paquetes);
    return cantidad;
}

/**
 * obtener_clases
 * ---------------------------------------------------------------------------
 *  Obtiene el array de clases de trafico que se utilizara en el analisis.
 *  Devuelve la cantidad de clases que contiene el array
 */
int obtener_clases(struct s_analizador *analizador)
{
    struct clase *c;
    #define REPETICIONES 2000
    #define CANT_PAQUETES 3 * REPETICIONES
    analizador->cant_clases = CANT_PAQUETES;
    c = analizador->clases = malloc(CANT_PAQUETES * sizeof(struct clase));
    /* La primer clase es la default */
    init_clase(c);
    strncpy(c->nombre, "Default", LONG_NOMBRE);
    strncpy(c->descripcion, "Clase por defecto", LONG_DESCRIPCION);
    /* XXX: Mock clases */
    for(int i = 0; i < REPETICIONES - 1; i++) {
        /* SSH */
        c++;
        init_clase(c);
        strncpy(c->nombre, "SSH", LONG_NOMBRE);
        strncpy(c->descripcion, "Secure shell - Administracion remota",
                LONG_DESCRIPCION);
        c->cant_puertos_a = 1;
        c->puertos_a = malloc(sizeof(u_int16_t));
        *(c->puertos_a) = 22;
        /* HTTP */
        c++;
        init_clase(c);
        strncpy(c->nombre, "HTTP", LONG_NOMBRE);
        strncpy(c->descripcion, "Navegacion web", LONG_DESCRIPCION);
        c->cant_puertos_a = 1;
        c->puertos_a = malloc(sizeof(u_int16_t));
        *(c->puertos_a) = 80;
        /* HTTPS */
        c++;
        init_clase(c);
        strncpy(c->nombre, "HTTPS", LONG_NOMBRE);
        strncpy(c->descripcion, "Navegacion web segura", LONG_DESCRIPCION);
        c->cant_puertos_a = 1;
        c->puertos_a = malloc(sizeof(u_int16_t));
        *(c->puertos_a) = 443;
    }
    return CANT_PAQUETES;
}

/**
 * free_clase
 * --------------------------------------------------------------------------
 *  Libera memoria ocupada por una clase de trafico
 */
void free_clase(struct clase *clase) {
    free(clase->subredes_a);
    free(clase->subredes_b);
    free(clase->puertos_a);
    free(clase->puertos_b);
}

/**
 * print_sqlca()
 * -------------------------------------------------------------------------
 * Imprime error en caso de ocurrir alguno
 */
void print_sqlca() {
    syslog(LOG_ERR, "==== sqlca ====\n");
    syslog(LOG_ERR, "sqlcode: %ld\n", sqlca.sqlcode);
    syslog(LOG_ERR, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    syslog(LOG_ERR, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    syslog(LOG_ERR, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],
                                                          sqlca.sqlerrd[1],
                                                          sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],
                                                          sqlca.sqlerrd[4],
                                                          sqlca.sqlerrd[5]);
    syslog(LOG_ERR, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0],
                                                          sqlca.sqlwarn[1],
                                                          sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3],
                                                          sqlca.sqlwarn[4],
                                                          sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6],
                                                          sqlca.sqlwarn[7]);
    syslog(LOG_ERR, "sqlstate: %5s\n", sqlca.sqlstate);
    syslog(LOG_ERR, "===============\n");
    fprintf(stderr, "Error: %s\n", sqlca.sqlerrm.sqlerrmc);
    exit(sqlca.sqlcode);
}
